<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal Session Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: #1e1e1e;
            color: #e0e0e0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: #2d2d2d;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #444;
        }
        
        .header h1 {
            font-size: 18px;
            color: #61dafb;
        }
        
        .controls {
            display: flex;
            gap: 10px;
        }
        
        button {
            background: #3a3a3a;
            color: #e0e0e0;
            border: 1px solid #555;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #4a4a4a;
            border-color: #61dafb;
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        button.primary {
            background: #2e7d32;
            border-color: #4caf50;
        }
        
        button.primary:hover {
            background: #388e3c;
        }
        
        button.danger {
            background: #c62828;
            border-color: #ef5350;
        }
        
        button.danger:hover {
            background: #d32f2f;
        }
        
        .terminal-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow: hidden;
        }
        
        .terminal {
            flex: 1;
            background: #0c0c0c;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            font-size: 14px;
            line-height: 1.5;
            overflow-y: auto;
            position: relative;
        }
        
        .terminal-output {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }
        
        .terminal-input-line {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        
        .prompt {
            color: #4caf50;
            margin-right: 8px;
            user-select: none;
        }
        
        .terminal-input {
            flex: 1;
            background: transparent;
            border: none;
            color: #e0e0e0;
            font-family: inherit;
            font-size: inherit;
            outline: none;
        }
        
        .terminal-cursor {
            display: inline-block;
            width: 8px;
            height: 18px;
            background: #e0e0e0;
            animation: blink 1s infinite;
            margin-left: 2px;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .status-bar {
            background: #2d2d2d;
            padding: 8px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid #444;
            font-size: 12px;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }
        
        .status-dot.connected {
            background: #4caf50;
            animation: pulse 2s infinite;
        }
        
        .status-dot.connecting {
            background: #ff9800;
            animation: pulse 1s infinite;
        }
        
        .status-dot.disconnected {
            background: #f44336;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal.show {
            display: flex;
        }
        
        .modal-content {
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
        }
        
        .modal h2 {
            color: #61dafb;
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
            font-size: 12px;
        }
        
        .form-group select,
        .form-group input {
            width: 100%;
            padding: 8px;
            background: #1e1e1e;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-family: inherit;
        }
        
        .form-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        
        /* ANSI color support */
        .ansi-black { color: #000000; }
        .ansi-red { color: #cd3131; }
        .ansi-green { color: #0dbc79; }
        .ansi-yellow { color: #e5e510; }
        .ansi-blue { color: #2472c8; }
        .ansi-magenta { color: #bc3fbc; }
        .ansi-cyan { color: #11a8cd; }
        .ansi-white { color: #e5e5e5; }
        
        .ansi-bright-black { color: #666666; }
        .ansi-bright-red { color: #f14c4c; }
        .ansi-bright-green { color: #23d18b; }
        .ansi-bright-yellow { color: #f5f543; }
        .ansi-bright-blue { color: #3b8eea; }
        .ansi-bright-magenta { color: #d670d6; }
        .ansi-bright-cyan { color: #29b8db; }
        .ansi-bright-white { color: #ffffff; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üñ•Ô∏è Terminal Session Manager</h1>
        <div class="controls">
            <button id="newSessionBtn" class="primary">New Session</button>
            <button id="reconnectBtn">Reconnect</button>
            <button id="clearBtn">Clear</button>
            <button id="closeBtn" class="danger">Close Session</button>
        </div>
    </div>
    
    <div class="terminal-container">
        <div class="terminal" id="terminal">
            <div class="terminal-output" id="output"></div>
            <div class="terminal-input-line">
                <span class="prompt" id="prompt">$</span>
                <input type="text" class="terminal-input" id="input" autofocus>
                <span class="terminal-cursor"></span>
            </div>
        </div>
    </div>
    
    <div class="status-bar">
        <div class="status-indicator">
            <span class="status-dot" id="statusDot"></span>
            <span id="statusText">Disconnected</span>
        </div>
        <div>
            <span id="sessionInfo">No active session</span>
        </div>
    </div>
    
    <!-- New Session Modal -->
    <div class="modal" id="newSessionModal">
        <div class="modal-content">
            <h2>Create New Terminal Session</h2>
            <div class="form-group">
                <label for="serverSelect">Select Server:</label>
                <select id="serverSelect">
                    <option value="">Loading servers...</option>
                </select>
            </div>
            <div class="form-actions">
                <button onclick="closeModal()">Cancel</button>
                <button class="primary" onclick="createSession()">Connect</button>
            </div>
        </div>
    </div>
    
    <script>
        class TerminalSession {
            constructor() {
                this.ws = null;
                this.sessionId = null;
                this.serverId = null;
                this.workingDirectory = '/home';
                this.commandHistory = [];
                this.historyIndex = -1;
                this.baseUrl = window.location.origin;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                
                this.output = document.getElementById('output');
                this.input = document.getElementById('input');
                this.prompt = document.getElementById('prompt');
                this.statusDot = document.getElementById('statusDot');
                this.statusText = document.getElementById('statusText');
                this.sessionInfo = document.getElementById('sessionInfo');
                
                this.initEventListeners();
                this.loadServers();
            }
            
            initEventListeners() {
                // Input handling
                this.input.addEventListener('keydown', (e) => this.handleInput(e));
                
                // Button controls
                document.getElementById('newSessionBtn').addEventListener('click', () => this.showNewSessionModal());
                document.getElementById('reconnectBtn').addEventListener('click', () => this.reconnect());
                document.getElementById('clearBtn').addEventListener('click', () => this.clearTerminal());
                document.getElementById('closeBtn').addEventListener('click', () => this.closeSession());
                
                // Window resize
                window.addEventListener('resize', () => this.handleResize());
            }
            
            async loadServers() {
                try {
                    const response = await fetch(`${this.baseUrl}/api/v1/servers`);
                    if (response.ok) {
                        const data = await response.json();
                        const select = document.getElementById('serverSelect');
                        select.innerHTML = '<option value="">Select a server...</option>';
                        
                        data.servers.forEach(server => {
                            const option = document.createElement('option');
                            option.value = server.id;
                            option.textContent = `${server.nickname || server.hostname} (${server.hostname})`;
                            select.appendChild(option);
                        });
                    }
                } catch (error) {
                    console.error('Failed to load servers:', error);
                    this.appendOutput('‚ùå Failed to load servers\n');
                }
            }
            
            showNewSessionModal() {
                document.getElementById('newSessionModal').classList.add('show');
            }
            
            async createSession() {
                const serverId = document.getElementById('serverSelect').value;
                if (!serverId) {
                    alert('Please select a server');
                    return;
                }
                
                this.serverId = serverId;
                this.updateStatus('connecting', 'Creating session...');
                
                try {
                    // Create terminal session
                    const response = await fetch(`${this.baseUrl}/api/v1/terminal/sessions`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ server_id: serverId })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.sessionId = data.session_id;
                        this.workingDirectory = data.working_directory;
                        
                        // Close modal
                        closeModal();
                        
                        // Connect WebSocket
                        this.connectWebSocket();
                    } else {
                        const error = await response.json();
                        this.appendOutput(`‚ùå Failed to create session: ${error.detail}\n`);
                        this.updateStatus('disconnected', 'Failed to create session');
                    }
                } catch (error) {
                    console.error('Failed to create session:', error);
                    this.appendOutput(`‚ùå Error: ${error.message}\n`);
                    this.updateStatus('disconnected', 'Connection failed');
                }
            }
            
            connectWebSocket() {
                if (!this.sessionId) return;
                
                const wsUrl = `${this.baseUrl.replace('http', 'ws')}/api/v1/terminal/${this.sessionId}/ws`;
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    this.updateStatus('connected', 'Connected');
                    this.sessionInfo.textContent = `Session: ${this.sessionId.substring(0, 8)}... | ${this.workingDirectory}`;
                    this.appendOutput('üîó Terminal session connected\n');
                    this.updatePrompt();
                    this.reconnectAttempts = 0;
                };
                
                this.ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    this.handleMessage(message);
                };
                
                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.appendOutput('‚ùå Connection error\n');
                };
                
                this.ws.onclose = () => {
                    this.updateStatus('disconnected', 'Disconnected');
                    this.appendOutput('üîå Connection closed\n');
                    
                    // Auto-reconnect logic
                    if (this.reconnectAttempts < this.maxReconnectAttempts) {
                        setTimeout(() => this.reconnect(), 2000);
                    }
                };
                
                // Send periodic ping to keep connection alive
                this.pingInterval = setInterval(() => {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify({ type: 'ping' }));
                    }
                }, 30000);
            }
            
            handleMessage(message) {
                switch (message.type) {
                    case 'connected':
                        this.workingDirectory = message.working_directory;
                        this.updatePrompt();
                        break;
                    
                    case 'output':
                        this.appendOutput(this.parseAnsiCodes(message.data));
                        break;
                    
                    case 'error':
                        this.appendOutput(`‚ùå ${message.data || message.message}\n`);
                        break;
                    
                    case 'directory_changed':
                        this.workingDirectory = message.working_directory;
                        this.updatePrompt();
                        this.sessionInfo.textContent = `Session: ${this.sessionId.substring(0, 8)}... | ${this.workingDirectory}`;
                        break;
                    
                    case 'pong':
                        // Keep-alive response
                        break;
                }
            }
            
            handleInput(event) {
                if (event.key === 'Enter') {
                    const command = this.input.value.trim();
                    if (command) {
                        this.executeCommand(command);
                        this.commandHistory.push(command);
                        this.historyIndex = this.commandHistory.length;
                    }
                    this.input.value = '';
                } else if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    if (this.historyIndex > 0) {
                        this.historyIndex--;
                        this.input.value = this.commandHistory[this.historyIndex];
                    }
                } else if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    if (this.historyIndex < this.commandHistory.length - 1) {
                        this.historyIndex++;
                        this.input.value = this.commandHistory[this.historyIndex];
                    } else {
                        this.historyIndex = this.commandHistory.length;
                        this.input.value = '';
                    }
                } else if (event.key === 'Tab') {
                    event.preventDefault();
                    // TODO: Implement tab completion
                } else if (event.ctrlKey && event.key === 'c') {
                    event.preventDefault();
                    this.sendInterrupt();
                } else if (event.ctrlKey && event.key === 'l') {
                    event.preventDefault();
                    this.clearTerminal();
                }
            }
            
            executeCommand(command) {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                    this.appendOutput('‚ùå Not connected to a terminal session\n');
                    return;
                }
                
                // Display command in terminal
                this.appendOutput(`${this.prompt.textContent} ${command}\n`);
                
                // Send command to server
                this.ws.send(JSON.stringify({
                    type: 'command',
                    command: command
                }));
            }
            
            sendInterrupt() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'input',
                        data: '\x03'  // Ctrl+C
                    }));
                }
            }
            
            async reconnect() {
                if (!this.sessionId) {
                    this.appendOutput('‚ùå No session to reconnect to\n');
                    return;
                }
                
                this.reconnectAttempts++;
                this.updateStatus('connecting', `Reconnecting... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                
                try {
                    const response = await fetch(`${this.baseUrl}/api/v1/terminal/sessions/${this.sessionId}/reconnect`, {
                        method: 'POST'
                    });
                    
                    if (response.ok) {
                        this.connectWebSocket();
                    } else if (response.status === 410) {
                        // Session expired
                        this.appendOutput('‚ö†Ô∏è Session expired. Creating new session...\n');
                        this.createSession();
                    } else {
                        throw new Error('Reconnection failed');
                    }
                } catch (error) {
                    console.error('Reconnection failed:', error);
                    this.updateStatus('disconnected', 'Reconnection failed');
                    this.appendOutput('‚ùå Failed to reconnect\n');
                }
            }
            
            async closeSession() {
                if (!this.sessionId) {
                    this.appendOutput('‚ùå No active session\n');
                    return;
                }
                
                if (confirm('Are you sure you want to close this session?')) {
                    try {
                        // Close WebSocket
                        if (this.ws) {
                            this.ws.close();
                        }
                        
                        // Close session on server
                        await fetch(`${this.baseUrl}/api/v1/terminal/sessions/${this.sessionId}`, {
                            method: 'DELETE'
                        });
                        
                        this.sessionId = null;
                        this.serverId = null;
                        this.updateStatus('disconnected', 'Session closed');
                        this.sessionInfo.textContent = 'No active session';
                        this.appendOutput('üëã Session closed\n');
                    } catch (error) {
                        console.error('Failed to close session:', error);
                        this.appendOutput('‚ùå Failed to close session properly\n');
                    }
                }
            }
            
            clearTerminal() {
                this.output.innerHTML = '';
            }
            
            appendOutput(text) {
                this.output.innerHTML += text;
                this.output.scrollTop = this.output.scrollHeight;
            }
            
            updatePrompt() {
                // Update prompt based on working directory
                const pathParts = this.workingDirectory.split('/');
                const currentDir = pathParts[pathParts.length - 1] || '~';
                this.prompt.textContent = `${currentDir} $`;
            }
            
            updateStatus(status, text) {
                this.statusDot.className = `status-dot ${status}`;
                this.statusText.textContent = text;
            }
            
            handleResize() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    const terminal = document.getElementById('terminal');
                    const cols = Math.floor(terminal.clientWidth / 8);
                    const rows = Math.floor(terminal.clientHeight / 20);
                    
                    this.ws.send(JSON.stringify({
                        type: 'resize',
                        cols: cols,
                        rows: rows
                    }));
                }
            }
            
            parseAnsiCodes(text) {
                // Basic ANSI escape code parsing
                return text
                    .replace(/\x1b\[0m/g, '</span>')
                    .replace(/\x1b\[1m/g, '<span style="font-weight:bold">')
                    .replace(/\x1b\[30m/g, '<span class="ansi-black">')
                    .replace(/\x1b\[31m/g, '<span class="ansi-red">')
                    .replace(/\x1b\[32m/g, '<span class="ansi-green">')
                    .replace(/\x1b\[33m/g, '<span class="ansi-yellow">')
                    .replace(/\x1b\[34m/g, '<span class="ansi-blue">')
                    .replace(/\x1b\[35m/g, '<span class="ansi-magenta">')
                    .replace(/\x1b\[36m/g, '<span class="ansi-cyan">')
                    .replace(/\x1b\[37m/g, '<span class="ansi-white">')
                    .replace(/\x1b\[90m/g, '<span class="ansi-bright-black">')
                    .replace(/\x1b\[91m/g, '<span class="ansi-bright-red">')
                    .replace(/\x1b\[92m/g, '<span class="ansi-bright-green">')
                    .replace(/\x1b\[93m/g, '<span class="ansi-bright-yellow">')
                    .replace(/\x1b\[94m/g, '<span class="ansi-bright-blue">')
                    .replace(/\x1b\[95m/g, '<span class="ansi-bright-magenta">')
                    .replace(/\x1b\[96m/g, '<span class="ansi-bright-cyan">')
                    .replace(/\x1b\[97m/g, '<span class="ansi-bright-white">');
            }
        }
        
        // Helper functions
        function closeModal() {
            document.querySelectorAll('.modal').forEach(modal => {
                modal.classList.remove('show');
            });
        }
        
        // Initialize terminal session
        const terminal = new TerminalSession();
        
        // Global function for modal
        window.createSession = () => terminal.createSession();
        window.closeModal = closeModal;
    </script>
</body>
</html>
